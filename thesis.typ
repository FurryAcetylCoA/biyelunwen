#import "nju-thesis/template.typ": documentclass, tablex, fig, tlt, indent
#import "nju-thesis/utils/style.typ": 字号, 字体

// 双面模式，会加入空白页，便于打印
#let twoside = false
// #let twoside = true

#let (
  doc, preface, mainmatter, mainmatter-end, appendix,
  fonts-display-page, cover, decl-page, abstract, abstract-en, outline-page, list-of-figures, list-of-tables, notation, acknowledgement,
) = documentclass(
  // anonymous: true,  // 盲审模式
  twoside: twoside,  // 双面模式，会加入空白页，便于打印
  // 可自定义字体，先英文字体后中文字体，应传入「宋体」、「黑体」、「楷体」、「仿宋」、「等宽」
   fonts: (楷体: ("Times New Roman", "LXGW WenKai GB"),
           仿宋: ("Times New Roman", "Zhuque Fangsong (technical preview)")),

  info: (
    title: ("基于Chisel的精简指令集微处理器设计"),
    title-en: ("Chisel implementation of a RISC microprocessor"),
    grade: "20物联网02",
    student-id: "19125042040",
    author: "荀阳霖",
    department: "信息工程学院",
    major: "物联网工程",
    supervisor: ("王娜", "讲师"),
    submit-date: datetime.today(),
  ),
)

// 文稿设置
#show: doc

// 字体展示测试页
//#fonts-display-page()

// 封面页
#cover()

// 前言
#show: preface

// 中文摘要
#abstract(
  keywords: ("我", "就是", "测试用", "关键词")
)[
  写完再摘

  #indent 高效抽象的处理器芯片
硬件设计语言与工具.快速迭代的芯片设计与
系统级原型验证方法(敏捷开发)让开发硬件像开发软件那
么容易
高质量芯片人才需要掌握计算机整体的软硬件理论知识与全程工程技术。既要在“学中做”，也要在“做中学” @ooicci 。
本文作者通过设计可运行基本操作系统的处理器芯片并完成投片。尝试贯穿芯片设计全链条，结合贯通计算机专业的诸多课程。
完成知识的有机融合，打通从数字电路、组成原理、体系结构、操作系统、嵌入式开发的全流程知识点。
]

// 英文摘要
#abstract-en(
  keywords: ("Dummy", "Keywords", "Here", "It Is")
)[
  English abstract
]

// 目录
#outline-page()

// 插图目录
//#list-of-figures()

// 表格目录
//#list-of-tables()

// 正文
#show: mainmatter

//使用外文缩写代替某一名词术语，首次出现时应在括号内注明其含义

= 绪论

== 研究工作的背景与意义


世界正在加速转型进入数字经济时代。而做为数字化引擎的处理器芯片，则是一切的基石。虽然信息领域市场巨大，竞争强烈，
但十几年来却已经形成了“赢家通吃”的场面。高精尖技术与人才长期被把握在少数西方大公司的壁垒之中。

随着中美贸易环境的变化和技术封锁措施，一些中国企业和高校被列入美国政府的‘实体清单’，这对中国芯片技术研发和人才培养带来了显著影响。
目前，我国的计算机专业人才培养面临着较大的结构问题。顶层应用开发者过多，而底层软硬件研发人员缺乏。
特别是芯片设计人才严重不足。2022年间我国集成电路产业人才缺口达到3.5万#cite(<供需报告>)。
这与当前芯片设计门槛过高，导致中国大学无法开展芯片相关教学与研究密切相关#cite(<方法思考与实践>)。

晶体管性能高速提升的时代即将结束，半导体行业即将进入后摩尔时代。提升芯片性能与能效的压力逐渐转移到了架构设计师与电路设计师上#cite(<golden>)。
对领域特定架构的需求日渐增加，产业界急需一种更加快速、灵活的研发方法和基础架构。

RISC-V是一款开源且免费的精简指令集架构。自从该指令集架构发布以来，在国内外吸引了许多关注。

如今，已有来自70多个国家的3900多个实体加入了RISC-V联盟，其中高级成员有超过40%来自中国。
开放的RISC-V架构鼓励了全球范围内的协作和技术创新，降低了进入壁垒，极大地促进学术界和创业公司在芯片设计领域的创新活动。
RISC-V具有开源免费、模块化、容易定制等特点，为我国芯片设计的发展带来了新的机遇。
有助于我国掌握核心关键技术的同时开放地对待国际交流与合作。

物联网时代的到来对处理器芯片提出了更多的需求。
RISC-V的模块化设计允许制造商根据特定应用场景进行裁剪或扩展，设计出高度优化的芯片解决方案，
降低功耗、提升性能并缩小芯片面积，进而降低成本。从而满足物联网行业中多样化、碎片化的市场需求。
同时，
鉴于物联网设备数量庞大且分布广泛，其安全问题愈发凸显。RISC-V因其透明的架构设计，有利于定制深度的防御策略，确保从硬件层面强化安全特性。
诸如“港华芯” @v5 这样的RISC-V物联网安全芯片的成功案例表明，RISC-V能够有效应对物联网安全挑战，并在能源、智慧城市等多个领域实现关键突破。

== 国内外研究现状

注：这块没写完

RISC-V具有简洁，现代的特点，受到了国内外的广泛关注。

在国际上，伯克利大学基于RISC-V指令集架构，使用Chisel语言构建来开源的SoC生成器，Rocket Chip @rocket 。由伯克利大学的研究团队于2012年推出。该生成器支持生成有序执行内核（Rocket）与乱序执行内核（Boom），还支持指令集扩展，协处理器等功能。
用户通过配置文件描述设计后，Rocket Chip生成器可以自动挑选所需的模块组合到设计中。


在国内，睿思芯科仅用了7个月的时间 @rsxk ，就完成了一款基于RISC-V的64位可编程终端AI芯片。这相比传统芯片设计效率提高了大概三倍。

中科院香山团队在2021年成功设计并流片了第一版雁栖湖架构处理器。在28nm 的工艺节点下达到 1.3GHz 的频率。
而后在2023年成功设计并流片了第二版南湖架构处理器，在 14nm 工艺节点下频率达到 2GHz。
香山处理器的目标是成为面向世界的体系结构创新开源平台，基础能力、设施、流程的建立是香山处理器长期高质量发展的关键，
香山团队设计了丰富的基础工具支撑起了这一复杂度量级的敏捷验证流程。

== 内容与结构安排 //（我们有要求这个吗）

= 处理器架构与敏捷开发 //working title

== 指令集架构

=== 复杂指令集与精简指令集

指令集发明于1960年代， 当时 IBM 为了解决该公司不同计算机产品线的程序无法通用的情况。
推出了完全独立于硬件架构的指令集架构（ISA）这一概念。

在当时，程序员通常直接使用汇编语言进行开发。因此市场普遍认为指令集应当更加丰富，每条指令本身应该能实现更多功能。
因此，当前一些高级语言中常见的概念，如函数调用、循环、数组访问都有直接对应的机器指令。
这使得早期的指令集均为复杂指令集（CISC）。

1980年开始，随着存储器成本大幅下降、指令数目持续增加、高级语言的普及，CISC的一些缺陷开始暴露。
指令利用率低、控制电路趋于复杂、研发周期过长、验证难度增加等  @theDawnofRisc 催生了对于精简指令集（RISC）的研究。

与CISC不同，RISC强调每条指令的功能单一化。通过指令的组合来完成复杂操作。
由于指令复杂程度下降，编译器更容易进行代码生成。同时节约的电路面积可以用于缓存或流水线等高级结构，RISC在成本与性能上均好于CISC


== RISC-V 指令集

2010年，David Patterson等人出于教学目的，在仔细评估了市面上各类指令集后，发现它们都存在设计上的不足 @waterman2016design 。
决定重头开始，吸取指令集架构领域25年期间的经验教训。设计了一款新的开源指令集架构—— RISC-V。

=== RISC-V 指令集的优势


- 基础加扩展式的ISA： RISC-V架构以模块化的方式组合在一起，用户可以根据需求选择不同模块以满足不同场景的应用。

- 紧凑的代码体积： 智能物联网产品对成本和存储空间通常较为敏感，RISC-V提供统一的指令压缩扩展，
 可以在同样的大小下存储更多指令，并且不对成本产生显著影响。

- 开放： 传统ISA高额的授权费和严格的使用限制对于学术界和初创企业来说是巨大的负担。
 而RISC-V的开源特性使得任何用户都可以免费使用该指令集而不需要缴纳授权费。
 通过开源许可模式，RISC-V打破了传统处理器授权的限制，有助于减少行业依赖于少数专有指令集架构的风险，促进公平竞争和市场活力。
 


- 简洁： RISC-V在设计之初参考了大量现有ISA的经验与缺点，设计更加现代化，基础指令只有40余条。
 避免了对某一特定微架构的过度优化，允许研究者在不被各类复杂的兼容性需求约束的情况下，自由探索各类微架构设计。

- 完整的软件支持：RISC-V提供完整的软件堆栈，编译器工具链以及继承开发环境和操作系统支持。




== 芯片敏捷开发方法及其应用

敏捷开发是一种现代软件开发方法论，它倡导迭代、增量开发，强调灵活性和响应变化的能力。
这种方法论源于对传统瀑布模型的反思与改进，后者往往在一个阶段结束后才转入下一个阶段，各个阶段间耦合度较高，且不易适应需求变更。
进而发展为项目延期，客户需求无法满足，甚至项目失败。

在敏捷开发中，项目被分解为一系列短周期（称为冲刺或迭代），每个周期专注于交付可用的产品增量。
团队在整个开发过程中持续集成、测试和交付，保证软件质量。
敏捷开发的核心价值观和原则体现在《敏捷宣言》#cite(<fowler2001agile>) 中，
包括重视个体和交互胜过流程和工具、可工作的软件高于详尽的文档、与客户协作并积极响应变化、以及持续交付并欢迎更改需求。


=== 敏捷开发的优点

传统的芯片开发流程包含一个固定的‘代码冻结’阶段，在此阶段之后，代码修订受到严格限制。
这就导致了后端物理设计团队的反馈不能及时有效地帮助前端架构团队改进设计。

而使用敏捷思想指导开发的硬件，在完成每一个功能点的编写后，前后端团队都会一起进行测试与验证。为快速改进设计提供了可能。

基于生成器的设计促进了模块在项目之间的重用。
敏捷开发可大幅降低芯片的设计周期，并在市场需求变化时快速响应。通过敏捷开发，伯克利大学的研究团队成功在五年内开发并生产了11种不同的处理器芯片。
#cite(<7436635>)。

=== 敏捷开发的意义

与传统互联网时代相比，智能物联网时代（AIoT）的设备成本功耗受限，专用性强。
传统上追求性能和通用的计算芯片不再适用。需要根据细分领域的需求，软硬件件协同优化，深度定制领域专用处理器（XPU）。
以满足特定场景对于芯片的成本，性能与能效需求。 #cite(<bao_1>)

这将使不同AIoT设备对芯片的需求差异化、专一化、碎片化。
如果继续沿用传统的瀑布式开发流程，过长的芯片研发和上市时间显然无法满足海量AIoT设备的快速定制需要。

=== 芯片行业的敏捷开发

在芯片设计领域中，敏捷开发意味着在设计初期就利用高级语言快速构建模拟器原型，软件的灵活性允许工程师快速尝试各种设计方案，
尽早获得反馈，并迅速迭代设计。
设计成熟后，敏捷开发流程允许团队在较短时间内将设计迁移到FPGA上进行验证和调试，
FPGA的高速和高准确性允许工程师在这一步运行完整的操作系统与测试程序。
同时与客户紧密合作，确保芯片设计能满足客户需求。
设计过程中，
设计完成后，可以通过电子设计自动化（EDA）工具对芯片电路的面积、功耗和时序进行细致的分析。
整个过程中，前端架构和后端物理团队同步协作，共同参与每次迭代的验证和优化，从而显著缩短了设计周期，提高了产品质量。

当芯片电路设计敲定后，就可以与晶圆厂对接，准备进行投片生产。

整个设计流程如 @fig:circle 所示。其前三步都可以通过敏捷开发大幅提高效率与质量。

#fig(image("images/circle.png", height: 38%) , caption: [芯片开发流程]) <circle>


== Chisel语言在芯片设计中的优势及其实现原理

目前，最流行的两种硬件定义语言（HDL）是Verilog和VHDL @vhdlverilog 。硬件工程师通过HDL描述硬件电路的具体行为与结构。
Verilog与VHDL最初都是为硬件仿真而创建的，后来才被用于综合。这些语言缺乏抽象能力，使得组件难以在项目之间重复使用。

Chisel #cite(<Chisel2012>) 是一种基于高级编程语言Scala @odersky2004overview 的新型硬件构造语言（HCL） 。由伯克利大学的研究团队于2012年推出。
Chisel在Scala中提供了各类硬件原语的抽象，使得工程师者可以用Scala类型描述电路接口，以Scala函数操作电路组件。
这种元编程可实现表现力强、可靠、类型安全的电路生成器，从而提高逻辑设计的效率和稳健性。

需要说明的是，虽然Chisel具有许多传统硬件描述语言不具备的高级特性，但其还是一门硬件构造语言，而不是高层次综合。
Chisel代码在运行后会生成对应硬件的形式化描述，以寄存器传输语言灵活中间码（Flexible Intermediate Representation for RTL，FIRRTL）形式记录 #cite(<Li:EECS-2016-9>) 。

FIRRTL随后被输入硬件编译框架(Hardware Compiler Framework，HCF) CIRCT @circt2021。
经过多次递降变换（lowering transformations） @mlir2021，逐级去除高层次的抽象，最终输出优化后的底层RTL代码（如Verilog）。
使用HCF的好处之一是其内置了大量的优化器，可进行常量传播、共用表达式合并、不可达代码消除或向专用集成电路（ASIC）与现场可编程门阵列（FPGA）提供针对性的优化#cite(<8203780>) 。
这些特点使工程师能够更专注于逻辑功能的设计，从而显著提升设计效率与代码质量。

=== Chisel的优点

==== 开发高效

Chisel语言的高效主要体现在四个方面： 

- 信号整体连接： Chisel丰富的类型系统和连接功能。允许工程师以组件化的方式声明和连接多个信号线，并进行整体连接。
  从而简化了总线接口修改的工作流程。
  避免了在使用传统HDL开发时，需要手动更新多个模块的端口声明而产生潜在错误。
  SystemVerilog虽提供类似的功能，但其端口定义不可嵌套，仍然无法达到良好的抽象程度。

- 元编程： Chisel可以抽象出多份相似模块的共用部分,通过使用参数化的硬件模板，工程师可以创建出可复用的硬件库。
  有效减少了代码冗余。SystemVerilog虽然提供类似的功能，但仅用于验证 @SV不可综合代码，属于不可综合代码。

- 面向对象：通过继承，工程师可以把Chisel中多个电路模块的共性抽提成一个父类。
  在实现具体模块时，只需通过继承的方式，就可以让模块自动拥有父类的所有特征。从而减少代码冗余，便于分层次设计。

- 函数式：Chisel的函数式特性将允许工程师使用map或zip算子实现电路级联的批处理操作，可以简洁地描述数据流。
  如 @fig:functional 所示，级联的算子操作可以直接对应生成后的电路。与Verilog的数据流建模相比，工程师不再需要关心运算符优先级。

#fig(image("images/functional.png", height: 38%) , caption: [函数式操作与电路设计紧密对应]) <functional>

==== 代码质量更优

余子濠等人（2019）的研究 @标签化 指出。
在FPGA上，与经验丰富的专职工程师使用Verilog相比，经训练的本科生使用Chisel的高级特性开发同样功能一致的二级缓存模块。
无论是能效、频率还是资源占用，均优于Verilog实现，且代码可维护性优更优。

#fig(
  tlt(
    columns: 3,
    [类型],        [Verilog], [Chisel],    
    [最高频率/MHz], [135],     [154],      
    [功耗/W],      [0.77],    [0.74], 
    [LUT 逻辑],    [5676],    [2594],
    [LUT RAM],    [1796],    [1492],    
    [触发器],      [4266],    [747],    
    [代码长度],    [618],     [155], 
    ),
  caption: [资源占用与性能对比],
) <verilogVSchisel>

#indent 在开发速度方面，专职工程师使用Verilog，消耗至少6周完成开发。而另一位有Chisel经验的本科生则在3天内完成了所有工作，
而且代码长度显著短于前者。

而在芯片整体设计方面，吕治宽（2022）的研究@lzk 表明，使用两种语言开发同一微结构的RISC-V处理器。Verilog的时间消耗是Chisel的3倍。



= 处理器微架构设计与实现

本文将首先实现一个单发射，简单流水线，顺序执行的基本RV32E扩展处理器芯片微架构。

为方便拓展，本微架构流水级之间使用异步定时方式通信，通过握手信号控制数据是否流动。
每个流水级的行为只取决于自身和下游模块的状态, 流水级均可以独立工作。
通过这种设计，避免了对全局控制器的需求，进而简化添加指令和流水级的难度。
也为探索乱序执行做好了准备。

在逻辑上，为了方便优化，
本微架构分为以下几个基础单元： 取指单元，译码单元，运算单元，访存单元，写回单元。
每个基础单元均可以根据自身情况产生 "准备/有效（Ready/ Valid）" 握手信号。
每个单元会通知前一级自身是否可以接收数据。并通知向下一级当前输出是否有效。

当时钟周期到来时，如果Ready与Valid均有效，表明数据准备完成，且下一级可以接收数据，则数据流向下一流水级。
如果Valid有效而Ready无效，表明虽然数据准备完成，但下一级暂时无法接收数据，此时本级受到反压（Backpressure），数据停止流动。

【这里放一张图】



== 取指单元

取指单元的总体架构如@fig:cpu_img0。

#fig(image("images/cpu_fetch.png", height: 25%) , caption: [取指单元总体架构]) <cpu_img0>

取值单元根据上一条指令的译码、执行结果修改程序计数器（PC），并取出下一条指令。

整个取值单元分成PC生成单元及指令访存单元。

=== PC生成单元

PC生成单元将根据当前处理器的状态以及指令来确定下一执行周期的程序计数器的值。
目前，程序计数器生成单元支持以下行为：

+ 顺序执行
+ 普通跳转（不切换特权级）
+ 暂停执行 
+ 自陷指令——陷入
+ 自陷指令——返回

RISCV架构支持比较两个通用寄存器的值并根据比较结果进行分支跳转（B系列指令）。无条件跳转（J系指令），
也支持在异常发生时进入异常处理程序并返回。PC寄存器的结构如@fig:cpu_pc_structure 所示,其行为如@tbl:next_pc_gen 所示。

#fig(
  tlt(
    columns: 5,
    [类型],      [add1], [add2],  [next_pc]     ,[PC寄存器],
    [顺序执行],   [pc],   [4],    [sum_next_pc]  ,[允许写入],
    [无条件跳转],  [pc],  [立即数], [sum_next_pc] ,[允许写入],
    [条件跳转],  [pc],  [据结果选择], [sum_next_pc] ,[允许写入], //RV的条件跳转是这样吗。确认一下
    [异常陷入],  [无关], [无关], [mtVec]       ,[允许写入],
    [异常返回],  [无关], [无关], [mePC ]       ,[允许写入],   
    [反压暂停],     [无关], [无关], [无关  ]       ,[禁止写入],        
    ),
  caption: [PC生成表],
) <next_pc_gen>


#fig(image("images/cpu_pc.png", height: 31%) , caption: [PC单元结构]) <cpu_pc_structure>

=== 指令访存单元

指令访存单元的任务是根据当前PC，向处理器核内的AXI[插入引用？]主机仲裁单元发起访存请求。其结构如@fig:imem_fsm  所示。
在复位后，指令访存控制器在`idle`状态等待有效的访存事务发生。收到访存请求后，按照@tbl:imem_fsm_tlb
的行为对取值单元的输出端口进行操作。需要注意的是，该状态机的输出均来自寄存器。

由于AXI协议规定在读事务完成时不再保持数据有效信号。在读取完成后，指令执行中的若干周期，指令有效信号
将由状态机提供【是这样的吗。我要确认一下】

#fig(image("images/inst-mem_stateMachine.png", height: 28%), caption: [取指单元状态机]) <imem_fsm>

#fig(
  tlt(
    columns: 3,
    [状态名],  [说明],                             [离开条件],
    [idle],    [当前未在访问指令存储器],           [存储器AXI读握手成功],
    [waiting], [读请求已发出。等待指令存储器回复], [存储器回复数据],
    [sending], [向CPU下游部件提供指令码],          [下游部件汇报准备完成]
    ),
  caption: [取指单元状态机转移说明],
) <imem_fsm_tlb>

#fig(image("images/inst-mem.png", height: 18%), caption: [取指单元结构]) <imem>



== 译码单元

== 运算单元

    [异常返回],  [未定义], [未定义], [mePC ]       ,[允许写入],    == 访存单元

== 写回单元


== dasd


引用@tbl:timing-tlt1,引用@tbl:timing-tlt，以及引用图表时，表格、图片和代码分别需要加上 `tbl:`、`fig:` 和 `lst:` 前缀才能正常显示编号。以及这里使用 `fig` 函数替代原生 `figure` 函数以支持将 `tablex` 作为表格来识别。

#align(center, (stack(dir: ltr)[
  #fig(
    tlt(
      columns: 2,
      [药品],   [规格],
      [浓氨水],  [分析纯AR],
      [盐酸],   [分析纯AR],
      [钛酸四丁酯], [≥99.0%]
    ),
    caption: [三线表1],
  ) <timing-tlt1>
][
  #h(50pt)
][
  #fig(
    tlt(
      columns: 4,
      map-cells: cell => {
        if cell.y > 0 and cell.x > 0 {
        cell.content = {
          let text-color = if int(cell.content.text) < 5 {
            red.lighten(30%)
          } else {
            green
          }
          set text(text-color)
          strong(cell.content)
        }
      }
      cell
    },
      [t], [1], [2], [3],
      [y], [3], [4], [9],
      [3], [3], [17], [0],
    ),
    caption: [三线表 - 着色],
  ) <timing-tlt>
]))


== 插图

插图必须精心制作，线条均匀，图面整洁。插图位于正文中引用该插图字段的后面。每幅插图应有图序和图题，图序和图题应放在图位下方居中处


== 数学公式

可以像 Markdown 一样写行内公式 $x + y$，以及带编号的行间公式：

$ phi.alt := (1 + sqrt(5)) / 2 $ <ratio>

引用数学公式需要加上 `eqt:` 前缀，则由@eqt:ratio，我们有：

$ F_n = floor(1 / sqrt(5) phi.alt^n) $

#indent 图表和公式后的段落要用 `#indent` 手动缩进。同时，我们也可以通过 `<->` 标签来标识该行间公式不需要编号

$ y = integral_1^2 x^2 dif x $ <->

而后续数学公式仍然能正常编号。

$ F_n = floor(1 / sqrt(5) phi.alt^n) $

== 参考文献

可以像这样引用参考文献：@wang2010guide 


== 代码块

```py
def add(x, y):
  return x + y
```


= 正文

== 正文子标题

=== 正文子子标题

正文内容


// 手动分页
#if (twoside) {
  pagebreak() + " "
}
// 参考文献
#bibliography(("bibs/ex01.bib", "bibs/ymlex.yml"),
  style: "./china-national-standard-gb-t-7714-2015-numeric.csl"
)



// 正文结束标志，不可缺少
#mainmatter-end()


// 手动分页
#if (twoside) {
  pagebreak() + " "
}

// 附录
#show: appendix

= 附录

== 附录子标题

=== 附录子子标题

附录内容，这里也可以加入图片，例如@fig:appendix-img。

#fig(
  image("nju-thesis/assets/vi/nju-emblem.svg", width: 20%),
  caption: [图片测试],
) <appendix-img>

// 手动分页
#if (twoside) {
  pagebreak() + " "
}

// 致谢
#acknowledgement[
  感谢 NJU-LUG，提供 NJUThesis Typst 模板。
]
